/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.parkgo.parkgorithm.background.storage;

import com.parkgo.parkgorithm.background.parking.ParkingHours;
import com.parkgo.parkgorithm.user.properties.Weekday;

/**
 * @author Antony
 */
public class PKHourlizer implements Serializer{
    private ParkingHours m_pkHours = null;
    
    /**
     * Default Constructor
     */
    public PKHourlizer(){
        // DO NOTHING
    }
    
    /**
     * Constructor
     * @param _pkHours[in] object to pack
     */
    public PKHourlizer(ParkingHours _pkHours){
        m_pkHours = _pkHours;
    }
    
    /**
     * Sets object to pack into buffer
     * @param _obj[in] object to pack
     * @return true if object passed can be packed else false.
     */
    @Override
    public boolean setObjectToPack(Object _obj){
        if (_obj == null)
            return (false);
        
        if (!ParkingHours.class.isAssignableFrom(_obj.getClass()))
            return (false);
        
        m_pkHours = (ParkingHours)_obj;
        return (true);
    }
    
    /**
     * Transforms object into a array buffer
     * Data packed is determined by the constructor
     * @return byte array representing object passed
     *        if object not set then return null
     */
    @Override
    public byte[] pack(){
        byte[] bTime = new byte[40];
        double[][] dTime;
        byte hour;
        byte min;
        int iIndex = 0;
        
        // Ensure data was set
        if (m_pkHours == null)
            return (null);
        
        dTime = m_pkHours.getTime(Weekday.ALL, Weekday.ALL);
        
        // Pack time into byte array 
        // Bits [5, 6]: [5,3,3,5,6,2,3,5,1,5,2,4,4,1,6,1,4,4,2,5,1,5]
        for (int i = 0; i < 4; i++){
            // MONDAY 
            hour = (byte)Math.floor(dTime[0][i]);
            min  = calculateMin(dTime[0][i]);
            bTime[iIndex]  = (byte)(hour << 3);
            bTime[iIndex++] |= ((0x38 & min) >> 3);
            bTime[iIndex]  = (byte)((0x07 & min) << 5);
            
            // TUESDAY
            min  = calculateMin(dTime[1][i]);
            bTime[iIndex++] |= (byte)Math.floor(dTime[1][i]);
            bTime[iIndex]  = (byte)(min << 2);
            
            // WEDNESDAY
            hour = (byte)Math.floor(dTime[2][i]);
            min  = calculateMin(dTime[2][i]);
            bTime[iIndex++] |= ((0x18 & hour) >> 3);
            bTime[iIndex]  = (byte)((0x07 & hour) << 5);
            bTime[iIndex++] |= ((0x3E & min) >> 1);
            bTime[iIndex]  = (byte)((0x01 & min) << 7);
            
            // THURSDAY
            min  = calculateMin(dTime[3][i]);
            bTime[iIndex] |=  ((byte)Math.floor(dTime[3][i])) << 2;
            bTime[iIndex++] |= (0x30 & min) >> 4;
            bTime[iIndex]  = (byte)((0x0F & min) << 4);
            
            // FRIDAY
            hour = (byte)Math.floor(dTime[4][i]);
            bTime[iIndex++] |= ((0x1E & hour) >> 1);
            bTime[iIndex]  = (byte)((0x01 & hour) << 7);
            bTime[iIndex] |= calculateMin(dTime[4][i]) << 1; 
            
            // SATURDAY
            hour = (byte)Math.floor(dTime[5][i]);
            min  = calculateMin(dTime[5][i]);
            bTime[iIndex++] |= ((0x10 & hour) >> 4);
            bTime[iIndex]  = (byte)((0x0F & hour) << 4);
            bTime[iIndex++] |= ((0x3C & min) >> 2);
            bTime[iIndex]  = (byte)((0x03 & min) << 6);
           
            // SUNDAY
            min  = calculateMin(dTime[6][i]);
            bTime[iIndex] |=  ((byte)Math.floor(dTime[6][i])) << 1;
            bTime[iIndex++] |=  ((0x20 & min) >> 5);
            bTime[iIndex++]  =  (byte)(0x1F & min);
        }
        
        return (bTime);
    }
    
    /**
     * Reverses the result of method pack
     * @param _data[in] packed time generated by method packTime
     * @return inst of ParkingHours if it was successful unpacking time 
     * information else null.
     */
    @Override
    public Object unpack(byte[] _data){
        if (_data.length != 40)
            return (false);
        
        ParkingHours pkHours = new ParkingHours();
        double dTime;
        byte   data;
        byte   hour;
        byte   min;
        int    iIndex = 0;
        
        // Unpack packed time
        // Bits [5, 6]: [5,3,3,5,6,2,3,5,1,5,2,4,4,1,6,1,4,4,2,5,1,5]
        for (int i = 0; i < 4; i++){
            // MONDAY 
            data = _data[iIndex++];
            dTime = (double)((0xF8 & data) >> 3); // hour            
            min = (byte)((0x03 & data) << 3);
            data = _data[iIndex++];
            min |= (0xE0 & data) >> 5;
            dTime += ((double)min) / 60.0; // minute
            pkHours.setTime(Weekday.MONDAY, dTime, i);
            
            // TUESDAY
            dTime = (double)(0x1F & data); // hour
            data = _data[iIndex++];
            dTime += (double)((0xFC & data) >> 2) / 60.0; // minute
            pkHours.setTime(Weekday.TUESDAY, dTime, i);
            
            // WEDNESDAY
            hour = (byte)((0x03 & data) << 3);
            data = _data[iIndex++];
            hour |= ((0xE0 & data) >> 5);
            dTime = (double)hour; // hour
            min = (byte)((0x1F & data) << 1);
            data = _data[iIndex++];
            min |= ((0x80 & data) >> 7);
            dTime += (double)min / 60.0; // minute
            pkHours.setTime(Weekday.WEDNESDAY, dTime, i);
            
            // THURSDAY
            dTime = (double)((0x7C & data) >> 2); // hour
            min = (byte)((0x03 & data) << 4);
            data = _data[iIndex++];
            min |= ((0xF0 & data) >> 4);
            dTime += (double)min / 60.0; // minute
            pkHours.setTime(Weekday.THURSDAY, dTime, i);
                    
            // FRIDAY
            hour = (byte)((0x0F & data) << 1);
            data = _data[iIndex++];
            hour |= ((0x80 & data) >> 7);
            dTime = (double)hour;
            dTime += ((double)((0x7E & data) >> 1)) / 60.0; // minute;
            pkHours.setTime(Weekday.FRIDAY, dTime, i);
            
            // SATURDAY
            hour = (byte)((0x01 & data) << 4);
            data = _data[iIndex++];
            hour |= ((0xF0 & data) >> 4);
            dTime = (double)hour;
            min = (byte)((0x0F & data) << 2);
            data = _data[iIndex++];
            min |= ((0xC0 & data) >> 6);
            dTime += (double)min / 60.0; // minute
            pkHours.setTime(Weekday.SATURDAY, dTime, i);
            
            // SUNDAY
            dTime = (double)((0x3E & data) >> 1);
            min = (byte)((0x01 & data) << 5);
            data = _data[iIndex++];
            min |= 0x1F & data;
            dTime += (double)min / 60.0; // minute
            pkHours.setTime(Weekday.SUNDAY, dTime, i);
        }
        
        
        return (pkHours);
    }
    
    /**
     * PRIVATE : Methods 
     */
    
    /**
     * Return minute value
     * @param _dTime[in] time value
     * @return minutes
     */
    private byte calculateMin(double _dTime){
        return ((byte)((_dTime - Math.floor(_dTime)) * 60.0));
    }
}
